package com.docflow.reports.service;

import com.docflow.reports.dto.DynamicReportRequest;
import com.docflow.reports.dto.ReportTemplateResponse;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.annotation.PostConstruct;
import org.springframework.dao.DataAccessException;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Service;
import org.springframework.web.server.ResponseStatusException;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.Instant;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@Service
public class ReportTemplateService {

    private static final String TABLE_NAME = "report_templates";

    private final NamedParameterJdbcTemplate jdbcTemplate;
    private final ObjectMapper objectMapper;
    private final RowMapper<ReportTemplateResponse> rowMapper = this::mapRow;

    public ReportTemplateService(NamedParameterJdbcTemplate jdbcTemplate, ObjectMapper objectMapper) {
        this.jdbcTemplate = jdbcTemplate;
        this.objectMapper = objectMapper;
    }

    @PostConstruct
    void ensureTable() {
        jdbcTemplate.getJdbcTemplate().execute(
                "CREATE TABLE IF NOT EXISTS " + TABLE_NAME + " (" +
                        "id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, " +
                        "name VARCHAR(255) NOT NULL, " +
                        "request_json CLOB NOT NULL, " +
                        "created_by VARCHAR(255) NOT NULL, " +
                        "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL" +
                        ")");
    }

    public ReportTemplateResponse save(String name, DynamicReportRequest request, String createdBy) {
        String trimmedName = optionalString(name);
        if (trimmedName == null || trimmedName.isEmpty()) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Template name is required");
        }

        DynamicReportRequest payload = Objects.requireNonNull(request, "request");
        String author = optionalString(createdBy);
        if (author == null || author.isEmpty()) {
            author = "system";
        }

        String requestJson;
        try {
            requestJson = objectMapper.writeValueAsString(payload);
        } catch (JsonProcessingException e) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Unable to serialise report request", e);
        }

        MapSqlParameterSource params = new MapSqlParameterSource()
                .addValue("name", trimmedName)
                .addValue("requestJson", requestJson)
                .addValue("createdBy", author);

        KeyHolder keyHolder = new GeneratedKeyHolder();
        try {
            jdbcTemplate.update(
                    "INSERT INTO " + TABLE_NAME + " (name, request_json, created_by, created_at) "
                            + "VALUES (:name, :requestJson, :createdBy, CURRENT_TIMESTAMP)",
                    params,
                    keyHolder,
                    new String[]{"id"});
        } catch (DataAccessException e) {
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Failed to store report template", e);
        }

        Number key = keyHolder.getKey();
        if (key == null) {
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Template identifier was not generated");
        }

        return getById(key.longValue());
    }

    public List<ReportTemplateResponse> listTemplates() {
        try {
            return jdbcTemplate.query(
                    "SELECT id, name, request_json, created_by, created_at FROM " + TABLE_NAME + " ORDER BY created_at DESC",
                    rowMapper);
        } catch (DataAccessException e) {
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Failed to load report templates", e);
        }
    }

    private ReportTemplateResponse getById(long id) {
        try {
            return jdbcTemplate.queryForObject(
                    "SELECT id, name, request_json, created_by, created_at FROM " + TABLE_NAME + " WHERE id = :id",
                    Map.of("id", id),
                    rowMapper);
        } catch (DataAccessException e) {
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Failed to load stored template", e);
        }
    }

    private ReportTemplateResponse mapRow(ResultSet rs, int rowNum) throws SQLException {
        long id = rs.getLong("id");
        String name = rs.getString("name");
        String createdBy = rs.getString("created_by");
        Timestamp createdAt = rs.getTimestamp("created_at");
        String json = rs.getString("request_json");
        DynamicReportRequest request;
        try {
            request = objectMapper.readValue(json, DynamicReportRequest.class);
        } catch (JsonProcessingException e) {
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Stored template is invalid", e);
        }
        Instant created = createdAt != null ? createdAt.toInstant() : Instant.now();
        return new ReportTemplateResponse(id, name, request, createdBy, created);
    }

    private String optionalString(String value) {
        if (value == null) {
            return null;
        }
        String trimmed = value.trim();
        return trimmed.isEmpty() ? null : trimmed;
    }
}
